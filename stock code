#!/usr/bin/env python3
"""
Live Stock Scanner - Polygon intraday + Alpaca fallback
Signals: SMA20/50 cross, RSI<35, MACD cross
Modes: dry (print), notify (webhook), paper (Alpaca paper trading)
"""

import os, time, argparse, requests
from datetime import datetime, timedelta
from typing import List
import pandas as pd

# --- ENV KEYS ---
POLY_KEY = os.getenv('POLYGON_API_KEY')
ALPACA_KEY = os.getenv('ALPACA_API_KEY')
ALPACA_SECRET = os.getenv('ALPACA_SECRET_KEY')
ALPACA_BASE = os.getenv('ALPACA_BASE_URL', 'https://paper-api.alpaca.markets')
WEBHOOK = os.getenv('NOTIFY_WEBHOOK')

# --- POLYGON INTRADAY ---
def _ts_to_dt(ms: int) -> pd.Timestamp:
    return pd.to_datetime(ms, unit='ms', utc=True).tz_convert('America/New_York')

def fetch_intraday_polygon(ticker: str) -> pd.DataFrame:
    if not POLY_KEY: raise RuntimeError('POLYGON_API_KEY not set')
    url = f'https://api.polygon.io/v2/aggs/ticker/{ticker}/range/1/minute/{datetime.now().strftime("%Y-%m-%d")}/{datetime.now().strftime("%Y-%m-%d")}'
    params = {'adjusted': 'true', 'sort': 'asc', 'limit': 50000, 'apiKey': POLY_KEY}
    all_results = []
    while True:
        r = requests.get(url, params=params, timeout=20)
        r.raise_for_status()
        j = r.json()
        results = j.get('results') or []
        all_results.extend(results)
        next_url = j.get('next_url')
        if not next_url: break
        url = next_url
        params = {}
        time.sleep(0.15)
    if not all_results: raise RuntimeError(f'No polygon bars for {ticker}')
    df = pd.DataFrame(all_results)
    df['t'] = df['t'].astype('int64')
    df = df.set_index(df['t'].apply(_ts_to_dt)).sort_index()
    df = df.rename(columns={'o':'Open','h':'High','l':'Low','c':'Close','v':'Volume'})
    return df[['Open','High','Low','Close','Volume']]

# --- ALPACA FALLBACK ---
try:
    from alpaca_trade_api.rest import REST
except Exception:
    REST = None

def fetch_intraday_alpaca(ticker: str) -> pd.DataFrame:
    if REST is None: raise RuntimeError('alpaca-trade-api not installed')
    if not ALPACA_KEY or not ALPACA_SECRET: raise RuntimeError('Alpaca keys not set')
    client = REST(ALPACA_KEY, ALPACA_SECRET, ALPACA_BASE)
    start = (datetime.utcnow() - timedelta(days=1)).strftime('%Y-%m-%d')
    end = datetime.utcnow().strftime('%Y-%m-%d')
    bars = client.get_bars(ticker,'1Min',start=start,end=end,adjustment='raw').df
    bars = bars.tz_convert('America/New_York')
    bars = bars.rename(columns={'open':'Open','high':'High','low':'Low','close':'Close','volume':'Volume'})
    return bars[['Open','High','Low','Close','Volume']]

# --- INDICATORS ---
def sma(series: pd.Series, w:int): return series.rolling(w, min_periods=w).mean()
def rsi(series: pd.Series, w:int=14):
    delta = series.diff()
    gain = delta.clip(lower=0).rolling(w).mean()
    loss = -delta.clip(upper=0).rolling(w).mean()
    rs = gain/(loss+1e-9)
    return 100 - (100/(1+rs))
def macd(series: pd.Series):
    fast = series.ewm(span=12, adjust=False).mean()
    slow = series.ewm(span=26, adjust=False).mean()
    macd_line = fast - slow
    signal = macd_line.ewm(span=9, adjust=False).mean()
    return macd_line, signal

def compute_signals(df: pd.DataFrame) -> dict:
    close = df['Close']
    sig_sma = (sma(close,20).iloc[-1] > sma(close,50).iloc[-1]) and (sma(close,20).iloc[-2] <= sma(close,50).iloc[-2])
    r = rsi(close).iloc[-1]
    sig_rsi = r < 35
    macd_line, macd_sig = macd(close)
    sig_macd = (macd_line.iloc[-1] > macd_sig.iloc[-1]) and (macd_line.iloc[-2] <= macd_sig.iloc[-2])
    return {'sma': sig_sma, 'rsi': sig_rsi, 'macd': sig_macd, 'rsi_value': float(r)}

# --- TRADING ---
def place_market_order(symbol: str, qty: int=1, side: str='buy'):
    client = REST(ALPACA_KEY, ALPACA_SECRET, ALPACA_BASE)
    return client.submit_order(symbol=symbol, qty=qty, side=side, type='market', time_in_force='day')

def notify_webhook(payload: dict):
    if not WEBHOOK: return
    try: requests.post(WEBHOOK,json=payload,headers={'Content-Type':'application/json'},timeout=8)
    except Exception as e: print('Webhook error', e)

# --- SCANNER LOOP ---
def parse_universe(u: str) -> List[str]: return [x.strip().upper() for x in u.split(',') if x.strip()]

def run_loop(universe: List[str], mode: str='dry', poll_seconds: int=60):
    last_alert = {}
    while True:
        for t in universe:
            try: df = fetch_intraday_polygon(t)
            except: df = fetch_intraday_alpaca(t)
            if len(df)<60: continue
            signals = compute_signals(df)
            now_bucket = df.index[-1]
            if last_alert.get(t)==now_bucket: continue
            if signals['sma'] or signals['macd'] or signals['rsi']:
                last_alert[t]=now_bucket
                payload={'ticker':t,'time':str(now_bucket),'signals':signals,'price':float(df['Close'].iloc[-1])}
                if mode=='notify': notify_webhook(payload)
                elif mode=='paper': place_market_order(t,qty=1)
                else: print('SIGNAL',payload)
            time.sleep(0.15)
        time.sleep(poll_seconds)

# --- MAIN ---
if __name__=='__main__':
    p = argparse.ArgumentParser()
    p.add_argument('--universe',required=True)
    p.add_argument('--mode',choices=['dry','notify','paper'],default='dry')
    p.add_argument('--poll-seconds',type=int,default=60)
    args = p.parse_args()
    run_loop(parse_universe(args.universe),mode=args.mode,poll_seconds=args.poll_seconds)